module test(
    input clk,
    input clr,          // 假定为低电平有效 (根据原代码 negedge)
    output reg [6:0] LED7S,  // 修正为标准 [6:0] 格式，个位秒（手动译码）
    output reg [3:0] LED7S2, // 十位秒（BCD）
    output reg [3:0] LED7S3, // 个位分（BCD）
    output reg [3:0] LED7S4, // 十位分（BCD）
    output reg [3:0] LED7S5, // 个位时（BCD）
    output reg [3:0] LED7S6  // 十位时（BCD）
);

    reg [5:0] sec;
    reg [5:0] min;
    reg [4:0] hour;
    
    // 用于辅助译码的临时变量
    reg [3:0] sec_unit_val; 

    // ==========================================
    // 1. 时钟计数与复位逻辑 (Clock and Reset)
    // ==========================================
    always @(posedge clk or negedge clr) begin
        if (!clr) begin
            // 异步复位：按下复位键时清零
            sec <= 0;
            min <= 0;
            hour <= 0;
        end
        else begin
            // 正常计数逻辑
            if (sec >= 59) begin
                sec <= 0;
                if (min >= 59) begin
                    min <= 0;
                    if (hour >= 23)
                        hour <= 0;
                    else
                        hour <= hour + 1;
                end
                else begin
                    min <= min + 1;
                end
            end
            else begin
                sec <= sec + 1;
            end
        end
    end

    // ==========================================
    // 2. 数位分离与输出逻辑 (Output Process)
    // ==========================================
    always @(*) begin
        // --- 数位分离部分 (完成你的任务1) ---
        
        // 秒 (sec)
        sec_unit_val = sec % 10;     // 取模得个位
        LED7S2       = sec / 10;     // 除法得十位
        
        // 分 (min)
        LED7S3       = min % 10;     // 个位
        LED7S4       = min / 10;     // 十位
        
        // 时 (hour)
        LED7S5       = hour % 10;    // 个位
        LED7S6       = hour / 10;    // 十位

        // --- 手动译码部分 (针对秒的个位) ---
        // 假设是共阴极还是共阳极取决于硬件，这里沿用你提供的编码
        // 4'b0000 -> 7'b1111110 (0x7E, 看起来像共阴极的高电平点亮，或者是共阳极的低电平有效)
        assign LED7S = (q == 4'b0000) ? 7'b1111110 :
               (q == 4'b0001) ? 7'b0110000 :
               (q == 4'b0010) ? 7'b1101101 :
               (q == 4'b0011) ? 7'b1111001 :
               (q == 4'b0100) ? 7'b0110011 :
               (q == 4'b0101) ? 7'b1011011 :
               (q == 4'b0110) ? 7'b1011111 :
               (q == 4'b0111) ? 7'b1110000 :
               (q == 4'b1000) ? 7'b1111111 :
               (q == 4'b1001) ? 7'b1111011 :
               7'b0000000;
        endcase
    end

endmodule